/*
 * Copyright 2025 The Closure Compiler Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Decorators for TypeScript classes.
 * NOTE: generated by tsickle, then manually edited to fix type errors.
 * Generated from: third_party/javascript/node_modules/typescript/stable/lib/lib.decorators.d.ts
 *
 * @externs
 */

/**
 * @template Class
 * @record
 * @struct
 */
function ClassDecoratorContext() {}
/** @const {string} */
ClassDecoratorContext.prototype.kind;
/** @const {(undefined|string)} */
ClassDecoratorContext.prototype.name;
/** @const {(undefined|?)} */
ClassDecoratorContext.prototype.metadata;

/**
 * Adds a callback to be invoked after the class definition has been finalized.
 *
 * \@example
 * ```ts
 * function customElement(name: string): ClassDecoratorFunction {
 *   return (target, context) => {
 *     context.addInitializer(function () {
 *       customElements.define(name, this);
 *     });
 *   }
 * }
 *
 * \@customElement("my-element")
 * class MyElement {}
 * ```
 * @public
 * @param {function(this: (Class)): void} initializer
 * @return {void}
 */
ClassDecoratorContext.prototype.addInitializer = function(initializer) {};
/**
 * @template This, Value
 * @record
 * @struct
 */
function ClassMethodDecoratorContext() {}
/** @const {string} */
ClassMethodDecoratorContext.prototype.kind;
/** @const {(string|symbol)} */
ClassMethodDecoratorContext.prototype.name;
/** @const {boolean} */
ClassMethodDecoratorContext.prototype.static;
/** @const {boolean} */
ClassMethodDecoratorContext.prototype.private;
/** @const {{has: function(This): boolean, get: function(This): Value}} */
ClassMethodDecoratorContext.prototype.access;
/** @const {(undefined|?)} */
ClassMethodDecoratorContext.prototype.metadata;

/**
 * Adds a callback to be invoked either after static methods are defined but before
 * static initializers are run (when decorating a `static` element), or before instance
 * initializers are run (when decorating a non-`static` element).
 *
 * \@example
 * ```ts
 * const bound: ClassMethodDecoratorFunction = (value, context) {
 *   if (context.private) throw new TypeError("Not supported on private methods.");
 *   context.addInitializer(function () {
 *     this[context.name] = this[context.name].bind(this);
 *   });
 * }
 *
 * class C {
 *   message = "Hello";
 *
 * \@bound
 *   m() {
 *     console.log(this.message);
 *   }
 * }
 * ```
 * @public
 * @param {function(this: (This)): void} initializer
 * @return {void}
 */
ClassMethodDecoratorContext.prototype.addInitializer = function(initializer) {};
/**
 * @template This, Value
 * @record
 * @struct
 */
function ClassGetterDecoratorContext() {}
/** @const {string} */
ClassGetterDecoratorContext.prototype.kind;
/** @const {(string|symbol)} */
ClassGetterDecoratorContext.prototype.name;
/** @const {boolean} */
ClassGetterDecoratorContext.prototype.static;
/** @const {boolean} */
ClassGetterDecoratorContext.prototype.private;
/** @const {{has: function(This): boolean, get: function(This): Value}} */
ClassGetterDecoratorContext.prototype.access;
/** @const {(undefined|?)} */
ClassGetterDecoratorContext.prototype.metadata;

/**
 * Adds a callback to be invoked either after static methods are defined but before
 * static initializers are run (when decorating a `static` element), or before instance
 * initializers are run (when decorating a non-`static` element).
 * @public
 * @param {function(this: (This)): void} initializer
 * @return {void}
 */
ClassGetterDecoratorContext.prototype.addInitializer = function(initializer) {};
/**
 * @template This, Value
 * @record
 * @struct
 */
function ClassSetterDecoratorContext() {}
/** @const {string} */
ClassSetterDecoratorContext.prototype.kind;
/** @const {(string|symbol)} */
ClassSetterDecoratorContext.prototype.name;
/** @const {boolean} */
ClassSetterDecoratorContext.prototype.static;
/** @const {boolean} */
ClassSetterDecoratorContext.prototype.private;
/** @const {{has: function(This): boolean, set: function(This, Value): void}} */
ClassSetterDecoratorContext.prototype.access;
/** @const {(undefined|?)} */
ClassSetterDecoratorContext.prototype.metadata;

/**
 * Adds a callback to be invoked either after static methods are defined but before
 * static initializers are run (when decorating a `static` element), or before instance
 * initializers are run (when decorating a non-`static` element).
 * @public
 * @param {function(this: (This)): void} initializer
 * @return {void}
 */
ClassSetterDecoratorContext.prototype.addInitializer = function(initializer) {};
/**
 * @template This, Value
 * @record
 * @struct
 */
function ClassAccessorDecoratorContext() {}
/** @const {string} */
ClassAccessorDecoratorContext.prototype.kind;
/** @const {(string|symbol)} */
ClassAccessorDecoratorContext.prototype.name;
/** @const {boolean} */
ClassAccessorDecoratorContext.prototype.static;
/** @const {boolean} */
ClassAccessorDecoratorContext.prototype.private;
/** @const {{has: function(This): boolean, get: function(This): Value, set: function(This, Value): void}} */
ClassAccessorDecoratorContext.prototype.access;
/** @const {(undefined|?)} */
ClassAccessorDecoratorContext.prototype.metadata;

/**
 * Adds a callback to be invoked immediately after the auto `accessor` being
 * decorated is initialized (regardless if the `accessor` is `static` or not).
 * @public
 * @param {function(this: (This)): void} initializer
 * @return {void}
 */
ClassAccessorDecoratorContext.prototype.addInitializer = function(initializer) {};
/**
 * @template This, Value
 * @record
 * @struct
 */
function ClassAccessorDecoratorTarget() {}

/**
 * Invokes the getter that was defined prior to decorator application.
 *
 * \@example
 * let value = target.get.call(instance);
 * @public
 * @this {This}
 * @return {Value}
 */
ClassAccessorDecoratorTarget.prototype.get = function() {};

/**
 * Invokes the setter that was defined prior to decorator application.
 *
 * \@example
 * target.set.call(instance, value);
 * @public
 * @this {This}
 * @param {Value} value
 * @return {void}
 */
ClassAccessorDecoratorTarget.prototype.set = function(value) {};
/**
 * @template This, Value
 * @record
 * @struct
 */
function ClassAccessorDecoratorResult() {}

/**
 * An optional replacement getter function. If not provided, the existing getter function is used instead.
 * @public
 * @this {This}
 * @return {Value}
 */
ClassAccessorDecoratorResult.prototype.get = function() {};

/**
 * An optional replacement setter function. If not provided, the existing setter function is used instead.
 * @public
 * @this {This}
 * @param {Value} value
 * @return {void}
 */
ClassAccessorDecoratorResult.prototype.set = function(value) {};

/**
 * An optional initializer mutator that is invoked when the underlying field initializer is evaluated.
 * @public
 * @this {This}
 * @param {Value} value The incoming initializer value.
 * @return {Value} The replacement initializer value.
 */
ClassAccessorDecoratorResult.prototype.init = function(value) {};
/**
 * @template This, Value
 * @record
 * @struct
 */
function ClassFieldDecoratorContext() {}
/** @const {string} */
ClassFieldDecoratorContext.prototype.kind;
/** @const {(string|symbol)} */
ClassFieldDecoratorContext.prototype.name;
/** @const {boolean} */
ClassFieldDecoratorContext.prototype.static;
/** @const {boolean} */
ClassFieldDecoratorContext.prototype.private;
/** @const {{has: function(This): boolean, get: function(This): Value, set: function(This, Value): void}} */
ClassFieldDecoratorContext.prototype.access;
/** @const {(undefined|?)} */
ClassFieldDecoratorContext.prototype.metadata;

/**
 * Adds a callback to be invoked immediately after the field being decorated
 * is initialized (regardless if the field is `static` or not).
 * @public
 * @param {function(this: (This)): void} initializer
 * @return {void}
 */
ClassFieldDecoratorContext.prototype.addInitializer = function(initializer) {};
